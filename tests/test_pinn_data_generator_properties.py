"""
EWP PINN Data Generator 属性测试

使用 hypothesis 进行属性测试，验证数据生成器的正确性。

Author: EFD-PINNs Team
Date: 2025-12-03
"""

import pytest
import numpy as np
import json
import tempfile
import os
from pathlib import Path
from hypothesis import given, strategies as st, settings, assume, HealthCheck

# 导入被测模块
from src.physics.pinn_data_generator import (
    # 数据类
    NormParams, SyntheticDataset, PhysicsConstraintPoints, ExperimentalDataset,
    ValidationResult,
    # 异常类
    ConfigurationError, ValidationError, DataIntegrityError,
    # 类
    SyntheticDataGenerator, PhysicsPointsSampler, ExperimentalDataLoader,
    DataAugmenter, DataPreprocessor, DataVisualizer, PINNDataGenerator,
    # 函数
    load_config, validate_config, fill_defaults, save_config,
    DEFAULT_CONFIG, REQUIRED_CONFIG_PARAMS
)
from src.solvers.flow_solver import MeshGenerator, Mesh


# ============================================================
# 测试策略
# ============================================================

# 电压策略 (0-30V)
voltage_strategy = st.floats(min_value=0, max_value=30, allow_nan=False, allow_infinity=False)

# 时间策略 (0-20ms)
time_strategy = st.floats(min_value=0, max_value=0.02, allow_nan=False, allow_infinity=False)

# 角度策略 (0-180度)
angle_strategy = st.floats(min_value=0, max_value=180, allow_nan=False, allow_infinity=False)

# 小正整数策略
small_int_strategy = st.integers(min_value=1, max_value=100)

# 归一化方法策略
norm_method_strategy = st.sampled_from(['standard', 'minmax'])


# ============================================================
# Fixtures
# ============================================================

@pytest.fixture
def mesh():
    """创建测试网格"""
    generator = MeshGenerator()
    return generator.generate_structured_mesh(nx=8, ny=8, nz=4)


@pytest.fixture
def sample_phi(mesh):
    """创建示例体积分数场"""
    generator = MeshGenerator()
    return generator.get_initial_phi(mesh)


@pytest.fixture
def physics_sampler(mesh):
    """创建物理点采样器"""
    return PhysicsPointsSampler(mesh)


@pytest.fixture
def exp_loader():
    """创建实验数据加载器"""
    return ExperimentalDataLoader()


@pytest.fixture
def augmenter():
    """创建数据增强器"""
    return DataAugmenter()


@pytest.fixture
def preprocessor():
    """创建数据预处理器"""
    return DataPreprocessor()


# ============================================================
# Property 4: 物理约束点域内性
# **Validates: Requirements 2.1**
# ============================================================

class TestPhysicsPointsDomainProperty:
    """
    **Feature: ewp-pinn-data-generation, Property 4: 物理约束点域内性**
    
    *For any* set of domain points generated by the sampler, 
    all points SHALL lie within the computational domain bounds.
    """
    
    @given(n_points=st.integers(min_value=10, max_value=500))
    @settings(max_examples=20, deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])
    def test_domain_points_within_bounds(self, mesh, n_points):
        """域内点应在计算域边界内"""
        sampler = PhysicsPointsSampler(mesh)
        points = sampler.sample_domain_points(n_points)
        
        # 检查点数
        assert len(points) == n_points
        
        # 检查坐标维度
        assert points.shape[1] == 4  # [x, y, z, t]
        
        # 检查 x 坐标范围
        assert np.all(points[:, 0] >= sampler.x_min)
        assert np.all(points[:, 0] <= sampler.x_min + sampler.Lx)
        
        # 检查 y 坐标范围
        assert np.all(points[:, 1] >= sampler.y_min)
        assert np.all(points[:, 1] <= sampler.y_min + sampler.Ly)
        
        # 检查 z 坐标范围
        assert np.all(points[:, 2] >= sampler.z_min)
        assert np.all(points[:, 2] <= sampler.z_min + sampler.Lz)


# ============================================================
# Property 5: 边界点位置正确性
# **Validates: Requirements 2.2**
# ============================================================

class TestBoundaryPointsProperty:
    """
    **Feature: ewp-pinn-data-generation, Property 5: 边界点位置正确性**
    
    *For any* set of boundary points generated by the sampler,
    all points SHALL lie on one of the six domain boundaries.
    """
    
    @given(n_points=st.integers(min_value=12, max_value=300))
    @settings(max_examples=20, deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])
    def test_boundary_points_on_boundaries(self, mesh, n_points):
        """边界点应在域边界上"""
        sampler = PhysicsPointsSampler(mesh)
        points, types = sampler.sample_boundary_points(n_points)
        
        # 检查点数（可能因为整除有少量差异）
        assert len(points) >= n_points - 6
        
        # 检查每个点是否在对应边界上
        tol = 1e-10
        
        for i, (pt, btype) in enumerate(zip(points, types)):
            x, y, z, t = pt
            
            if btype == 0:  # bottom (z = z_min)
                assert abs(z - sampler.z_min) < tol
            elif btype == 1:  # top (z = z_min + Lz)
                assert abs(z - (sampler.z_min + sampler.Lz)) < tol
            elif btype == 2:  # front (y = y_min)
                assert abs(y - sampler.y_min) < tol
            elif btype == 3:  # back (y = y_min + Ly)
                assert abs(y - (sampler.y_min + sampler.Ly)) < tol
            elif btype == 4:  # left (x = x_min)
                assert abs(x - sampler.x_min) < tol
            elif btype == 5:  # right (x = x_min + Lx)
                assert abs(x - (sampler.x_min + sampler.Lx)) < tol


# ============================================================
# Property 7: 物理约束点输出完整性
# **Validates: Requirements 2.5**
# ============================================================

class TestPhysicsPointsCompletenessProperty:
    """
    **Feature: ewp-pinn-data-generation, Property 7: 物理约束点输出完整性**
    
    *For any* generated physics constraint point set, the output SHALL contain
    coordinates (x, y, z, t) and associated physical parameters (V, θ).
    """
    
    @given(
        voltage=voltage_strategy,
        theta=st.floats(min_value=60, max_value=120, allow_nan=False)
    )
    @settings(max_examples=20, deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])
    def test_constraint_points_completeness(self, mesh, sample_phi, voltage, theta):
        """物理约束点应包含完整的坐标和物理参数"""
        sampler = PhysicsPointsSampler(mesh)
        
        points = sampler.generate_constraint_points(
            n_domain=100,
            n_boundary=50,
            n_interface=20,
            n_contact=10,
            phi=sample_phi,
            voltage=voltage,
            theta=theta
        )
        
        # 检查坐标维度
        assert points.domain_points.shape[1] == 4
        assert points.boundary_points.shape[1] == 4
        
        # 检查物理参数
        assert points.voltage == voltage
        assert points.contact_angle == theta
        
        # 检查 has_required_fields 方法
        assert points.has_required_fields()


# ============================================================
# Property 8: 实验数据验证
# **Validates: Requirements 3.5**
# ============================================================

class TestExperimentalDataValidationProperty:
    """
    **Feature: ewp-pinn-data-generation, Property 8: 实验数据验证**
    
    *For any* experimental data loaded from a file, if required fields are missing,
    the loader SHALL raise a validation error listing the missing fields.
    """
    
    def test_missing_time_series_validation(self, exp_loader):
        """缺少时间序列应报告错误"""
        data = ExperimentalDataset(
            t=np.array([]),  # 空时间序列
            aperture_ratio=np.array([0.1, 0.2]),
            voltage=30.0
        )
        
        result = exp_loader.validate(data)
        
        assert not result.is_valid
        assert any('时间' in err or 'time' in err.lower() for err in result.errors)
    
    def test_missing_aperture_ratio_validation(self, exp_loader):
        """缺少开口率应报告错误"""
        data = ExperimentalDataset(
            t=np.array([0, 0.001, 0.002]),
            aperture_ratio=np.array([]),  # 空开口率
            voltage=30.0
        )
        
        result = exp_loader.validate(data)
        
        assert not result.is_valid
        assert any('开口率' in err or 'aperture' in err.lower() for err in result.errors)
    
    def test_length_mismatch_validation(self, exp_loader):
        """长度不一致应报告错误"""
        data = ExperimentalDataset(
            t=np.array([0, 0.001, 0.002]),
            aperture_ratio=np.array([0.1, 0.2]),  # 长度不匹配
            voltage=30.0
        )
        
        result = exp_loader.validate(data)
        
        assert not result.is_valid
        assert any('长度' in err or '不一致' in err for err in result.errors)
    
    def test_valid_data_passes(self, exp_loader):
        """有效数据应通过验证"""
        data = ExperimentalDataset(
            t=np.array([0, 0.001, 0.002]),
            aperture_ratio=np.array([0.0, 0.2, 0.4]),
            voltage=30.0
        )
        
        result = exp_loader.validate(data)
        
        assert result.is_valid
        assert len(result.errors) == 0


# ============================================================
# Property 9: 空间增强正确性
# **Validates: Requirements 4.1, 4.2**
# ============================================================

class TestSpatialAugmentationProperty:
    """
    **Feature: ewp-pinn-data-generation, Property 9: 空间增强正确性**
    
    *For any* 3D field data, applying rotation or reflection SHALL produce
    output with the same dimensions as input.
    """
    
    @given(
        nx=st.integers(min_value=4, max_value=16),
        ny=st.integers(min_value=4, max_value=16),
        nz=st.integers(min_value=2, max_value=8),
        angle=st.sampled_from([90, 180, 270])
    )
    @settings(max_examples=30, deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])
    def test_rotation_preserves_dimensions(self, augmenter, nx, ny, nz, angle):
        """旋转应保持数据维度"""
        data = np.random.rand(nx, ny, nz)
        rotated = augmenter.rotate(data, angle)
        
        # 90° 和 270° 旋转会交换 x 和 y 维度
        if angle in [90, 270]:
            assert rotated.shape == (ny, nx, nz)
        else:  # 180°
            assert rotated.shape == (nx, ny, nz)
    
    @given(
        nx=st.integers(min_value=4, max_value=16),
        ny=st.integers(min_value=4, max_value=16),
        nz=st.integers(min_value=2, max_value=8),
        axis=st.sampled_from(['x', 'y'])
    )
    @settings(max_examples=30, deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])
    def test_reflection_preserves_dimensions(self, augmenter, nx, ny, nz, axis):
        """翻转应保持数据维度"""
        data = np.random.rand(nx, ny, nz)
        reflected = augmenter.reflect(data, axis)
        
        assert reflected.shape == data.shape


# ============================================================
# Property 11: 归一化往返一致性
# **Validates: Requirements 5.3**
# ============================================================

class TestNormalizationRoundtripProperty:
    """
    **Feature: ewp-pinn-data-generation, Property 11: 归一化往返一致性**
    
    *For any* dataset, normalizing then denormalizing with the saved parameters
    SHALL recover the original data within floating-point tolerance.
    """
    
    @given(
        data=st.lists(
            st.floats(min_value=-1000, max_value=1000, allow_nan=False, allow_infinity=False),
            min_size=10, max_size=100
        ),
        method=norm_method_strategy
    )
    @settings(max_examples=50, deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])
    def test_normalization_roundtrip(self, preprocessor, data, method):
        """归一化后反归一化应恢复原数据"""
        original = np.array(data)
        
        # 跳过常数数组（标准差为0）
        if np.std(original) < 1e-10:
            assume(False)
        
        normalized, params = preprocessor.normalize(original, method=method)
        recovered = preprocessor.denormalize(normalized, params)
        
        # 检查恢复误差
        max_error = np.max(np.abs(recovered - original))
        relative_error = max_error / (np.max(np.abs(original)) + 1e-10)
        
        assert relative_error < 1e-6, f"相对误差 {relative_error} 超过阈值"


# ============================================================
# Property 12: 数据分割比例正确性
# **Validates: Requirements 5.4**
# ============================================================

class TestDataSplitRatioProperty:
    """
    **Feature: ewp-pinn-data-generation, Property 12: 数据分割比例正确性**
    
    *For any* dataset split with ratios, the resulting split sizes SHALL match
    the specified ratios within ±1 sample.
    """
    
    @given(
        n_voltage=st.integers(min_value=5, max_value=20),
        train_ratio=st.floats(min_value=0.5, max_value=0.8)
    )
    @settings(max_examples=30, deadline=None, suppress_health_check=[HealthCheck.function_scoped_fixture])
    def test_split_ratio_correctness(self, preprocessor, n_voltage, train_ratio):
        """分割比例应正确"""
        val_ratio = (1 - train_ratio) / 2
        
        # 创建模拟数据集
        dataset = SyntheticDataset(
            mesh_info={'nx': 4, 'ny': 4, 'nz': 2},
            t=np.linspace(0, 0.02, 10),
            voltages=np.linspace(0, 30, n_voltage),
            u=np.zeros((n_voltage, 10, 4, 4, 2)),
            v=np.zeros((n_voltage, 10, 4, 4, 2)),
            w=np.zeros((n_voltage, 10, 4, 4, 2)),
            p=np.zeros((n_voltage, 10, 4, 4, 2)),
            phi=np.zeros((n_voltage, 10, 4, 4, 2)),
            aperture_ratio=np.zeros((n_voltage, 10)),
            contact_angle=np.zeros((n_voltage, 10))
        )
        
        train, val, test = preprocessor.split(dataset, train_ratio, val_ratio)
        
        # 检查总数
        total = 0
        if train is not None:
            total += len(train.voltages)
        if val is not None:
            total += len(val.voltages)
        if test is not None:
            total += len(test.voltages)
        
        assert total == n_voltage


# ============================================================
# Property 16: 模板数据可加载性
# **Validates: Requirements 7.5**
# ============================================================

class TestTemplateLoadabilityProperty:
    """
    **Feature: ewp-pinn-data-generation, Property 16: 模板数据可加载性**
    
    *For any* generated template file, loading the template with the data loader
    SHALL succeed without validation errors.
    """
    
    def test_json_template_loadable(self, exp_loader):
        """JSON 模板应可加载"""
        with tempfile.TemporaryDirectory() as tmpdir:
            template_path = Path(tmpdir) / 'template.json'
            exp_loader.generate_template_json(str(template_path))
            
            # 加载模板
            data = exp_loader.load_json(str(template_path))
            
            # 验证数据
            result = exp_loader.validate(data)
            
            assert result.is_valid, f"模板验证失败: {result.errors}"
    
    def test_csv_template_loadable(self, exp_loader):
        """CSV 模板应可加载"""
        with tempfile.TemporaryDirectory() as tmpdir:
            template_path = Path(tmpdir) / 'template.csv'
            exp_loader.generate_template_csv(str(template_path))
            
            # 加载模板
            data = exp_loader.load_csv(str(template_path))
            
            # 验证数据
            result = exp_loader.validate(data)
            
            assert result.is_valid, f"模板验证失败: {result.errors}"


# ============================================================
# Property 17: 可视化输出存在性
# **Validates: Requirements 8.5**
# ============================================================

class TestVisualizationOutputProperty:
    """
    **Feature: ewp-pinn-data-generation, Property 17: 可视化输出存在性**
    
    *For any* visualization request with a specified output path,
    the system SHALL create a file at that path.
    """
    
    def test_spatial_distribution_creates_file(self, mesh):
        """空间分布图应创建文件"""
        with tempfile.TemporaryDirectory() as tmpdir:
            visualizer = DataVisualizer(tmpdir)
            
            # 创建测试点
            points = np.random.rand(100, 4) * 1e-4
            
            save_path = 'test_spatial.png'
            visualizer.plot_spatial_distribution(points, save_path)
            
            # 检查文件存在
            assert (Path(tmpdir) / save_path).exists()


# ============================================================
# Property 18: 配置验证
# **Validates: Requirements 9.2**
# ============================================================

class TestConfigValidationProperty:
    """
    **Feature: ewp-pinn-data-generation, Property 18: 配置验证**
    
    *For any* configuration file missing required parameters,
    loading SHALL raise a validation error listing the missing parameters.
    """
    
    def test_missing_required_params_detected(self):
        """缺少必需参数应被检测到"""
        incomplete_config = {
            'synthetic_data': {
                # 缺少 voltage_range
                'time_range': [0, 0.02]
            }
        }
        
        missing = validate_config(incomplete_config)
        
        assert len(missing) > 0
        assert 'synthetic_data.voltage_range' in missing
    
    def test_complete_config_passes(self):
        """完整配置应通过验证"""
        complete_config = {
            'synthetic_data': {
                'voltage_range': [0, 30],
                'time_range': [0, 0.02]
            },
            'preprocessing': {
                'train_ratio': 0.7
            }
        }
        
        missing = validate_config(complete_config)
        
        assert len(missing) == 0


# ============================================================
# Property 19: 默认值应用
# **Validates: Requirements 9.3**
# ============================================================

class TestDefaultValuesProperty:
    """
    **Feature: ewp-pinn-data-generation, Property 19: 默认值应用**
    
    *For any* configuration file with omitted optional parameters,
    the loaded configuration SHALL contain default values for those parameters.
    """
    
    def test_defaults_filled(self):
        """可选参数应填充默认值"""
        partial_config = {
            'synthetic_data': {
                'voltage_range': [0, 30]
            }
        }
        
        filled = fill_defaults(partial_config)
        
        # 检查默认值被填充
        assert 'time_range' in filled['synthetic_data']
        assert 'mesh' in filled['synthetic_data']
        assert 'physics_points' in filled
        assert 'augmentation' in filled
        assert 'preprocessing' in filled


# ============================================================
# Property 20: 配置保存
# **Validates: Requirements 9.5**
# ============================================================

class TestConfigSaveProperty:
    """
    **Feature: ewp-pinn-data-generation, Property 20: 配置保存**
    
    *For any* completed data generation, the effective configuration
    SHALL be saved alongside the generated data.
    """
    
    def test_config_saved_with_data(self):
        """配置应与数据一起保存"""
        with tempfile.TemporaryDirectory() as tmpdir:
            config_path = Path(tmpdir) / 'config.json'
            
            test_config = {
                'test_key': 'test_value',
                'nested': {'key': 123}
            }
            
            save_config(test_config, str(config_path))
            
            # 检查文件存在
            assert config_path.exists()
            
            # 检查内容正确
            with open(config_path, 'r') as f:
                loaded = json.load(f)
            
            assert loaded == test_config


# ============================================================
# NormParams 序列化测试
# ============================================================

class TestNormParamsSerialization:
    """NormParams 序列化测试"""
    
    @given(
        method=norm_method_strategy,
        values=st.lists(st.floats(min_value=-100, max_value=100, allow_nan=False), min_size=5, max_size=10)
    )
    @settings(max_examples=20, deadline=None)
    def test_norm_params_roundtrip(self, method, values):
        """NormParams 序列化往返一致性"""
        arr = np.array(values)
        
        if method == 'standard':
            params = NormParams(method='standard', mean=arr, std=arr + 1)
        else:
            params = NormParams(method='minmax', min_val=arr, max_val=arr + 10)
        
        # 序列化
        d = params.to_dict()
        
        # 反序列化
        recovered = NormParams.from_dict(d)
        
        assert recovered.method == params.method
        if method == 'standard':
            np.testing.assert_array_almost_equal(recovered.mean, params.mean)
            np.testing.assert_array_almost_equal(recovered.std, params.std)
        else:
            np.testing.assert_array_almost_equal(recovered.min_val, params.min_val)
            np.testing.assert_array_almost_equal(recovered.max_val, params.max_val)


if __name__ == '__main__':
    pytest.main([__file__, '-v', '--tb=short'])
